{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p> Multi-tenancy with SQLAlchemy made easy. </p> <p> </p> <p><code>sqlalchemy-tenants</code> makes it easy and safe to implement multi-tenancy in your  application using SQLAlchemy. It enables you to securely  share a single database among multiple tenants preventing accidental data leaks  or cross-tenant writes thanks to Row-Level Security (RLS).</p> SyncAsync <pre><code>from sqlalchemy_tenants import with_rls\nfrom sqlalchemy_tenants.managers import PostgresManager\n\nengine = create_engine(\"postgresql+psycopg://user:password@localhost/dbname\")\nmanager = PostgresManager.from_engine(engine, schema=\"public\")\n\n@with_rls\nclass MyTable(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column()\n    tenant: Mapped[str] = mapped_column()  # Required tenant column\n\nwith manager.new_tenant_session(\"tenant_1\") as session:\n    # \u2705 Only returns tenant_1\u2019s rows\n    session.execute(select(MyTable))  \n\n    # \u274c Raises error: mismatched tenant\n    session.execute(  \n        insert(MyTable).values(id=1, name=\"Example\", tenant=\"tenant_2\")\n    )\n\n    # \u2705 Correct insert: use session.tenant for current tenant\n    session.execute(\n        insert(MyTable).values(id=1, name=\"Example\", tenant=session.tenant)\n    )\n</code></pre> <pre><code>from sqlalchemy_tenants import with_rls\nfrom sqlalchemy_tenants.aio.managers import PostgresManager\n\nengine = create_async_engine(\"postgresql+asyncpg://user:password@localhost/dbname\")\nmanager = PostgresManager.from_engine(engine, schema=\"public\")\n\n@with_rls\nclass MyTable(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column()\n    tenant: Mapped[str] = mapped_column()  # Required tenant column\n\nasync with manager.new_tenant_session(\"tenant_1\") as session:\n    # \u2705 Only returns tenant_1\u2019s rows\n    await session.execute(select(MyTable))  \n\n    # \u274c Raises error: mismatched tenant\n    await session.execute(  \n        insert(MyTable).values(id=1, name=\"Example\", tenant=\"tenant_2\")\n    )\n\n    # \u2705 Correct insert: use session.tenant for current tenant\n    await session.execute(\n        insert(MyTable).values(id=1, name=\"Example\", tenant=session.tenant)\n    )\n</code></pre>"},{"location":"#key-features","title":"Key features","text":"<p>\ud83d\udd12 Strong Data Segregation via Row-Level Security (RLS): All queries and writes are  automatically scoped to the active tenant using Level Security (RLS).  This ensures strict tenant isolation, even when tenant filters are accidentally  omitted from your queries.</p> <p>\u2699\ufe0f Straightforward Integration: Add multi-tenancy to your existing models with  minimal changes: simply define a tenant column, apply the @with_rls decorator, and use  the session manager to enforce tenant scoping automatically.</p> <p>\ud83d\udce6 Full SQLAlchemy support: Fully compatible with both  sync and async SQLAlchemy engines, sessions, and declarative models. </p>"},{"location":"#supported-databases","title":"Supported databases","text":"<ul> <li>PostgreSQL: Currently, only PostgreSQL is supported, leveraging its native  Row-Level Security (RLS) to isolate tenant data. Support for additional databases  is planned.</li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":""},{"location":"#1-install-the-library","title":"1. Install the library","text":"UVPoetryPip <pre><code>uv add sqlalchemy-tenants\n</code></pre> <pre><code>poetry add sqlalchemy-tenants\n</code></pre> <pre><code>pip install sqlalchemy-tenants\n</code></pre>"},{"location":"#2-annotate-your-models","title":"2. Annotate your models","text":"<p>Add the <code>@with_rls</code> decorator to any model that should be tenant-aware.</p> <p>It enables multi-tenancy enforcement on that table and allows the session manager to  apply tenant scoping automatically.</p> <p>Your model must include a <code>tenant</code> column of type <code>str</code>, which contains the  tenant identifier (e.g. a slug).  If the model doesn\u2019t already have this column, you\u2019ll need to add it.</p> <pre><code>from sqlalchemy_tenants import with_rls\n\n@with_rls\nclass MyTable(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column()\n    tenant: Mapped[str] = mapped_column()  # Required tenant column\n</code></pre>"},{"location":"#3-update-your-alembic-envpy","title":"3. Update your Alembic <code>env.py</code>","text":"<p>Include sqlalchemy-tenants in your Alembic <code>env.py</code> to automatically generate  RLS policies and functions in your migrations.</p> <p>You can just add the function <code>get_process_revision_directives</code> to your <code>context.configure</code> call:</p> env.py<pre><code>from alembic import context\nfrom app.db.orm import Base\nfrom sqlalchemy_tenants import get_process_revision_directives\n\ntarget_metadata = Base.metadata\n\ncontext.configure(\n    # ...\n    process_revision_directives=get_process_revision_directives(target_metadata),\n    # ...\n)\n</code></pre>"},{"location":"#4-generate-migrations","title":"4. Generate migrations","text":"<p>Use Alembic to generate a new migration, which will include the necessary RLS policies and functions for your tenant-aware models:</p> <pre><code>alembic revision --autogenerate -m \"Add RLS policies\"\n</code></pre>"},{"location":"#5-create-a-dbmanager","title":"5. Create a DBManager","text":"<p><code>sqlalchemy-tenants</code> provides a <code>DBManager</code> to simplify the creation of tenant-scoped sessions.</p> <p>Instantiate it from your SQLAlchemy engine and specify the schema where  your tenant-aware tables live. The manager will automatically scope all operations  (like RLS enforcement) to that schema.</p> SyncAsync <pre><code>from sqlalchemy import create_engine\nfrom sqlalchemy_tenants.managers import PostgresManager\n\nengine = create_engine(\"postgresql+psycopg://user:password@localhost/dbname\")\nmanager = PostgresManager.from_engine(\n    engine,\n    schema=\"public\", # (1)\n)\n</code></pre> <ol> <li>The schema where your tenant-aware tables are located. All sessions and RLS checks will be scoped to this schema.</li> </ol> <pre><code>from sqlalchemy.ext.asyncio import create_async_engine\nfrom sqlalchemy_tenants.aio.managers import PostgresManager\n\nengine = create_async_engine(\"postgresql+asyncpg://user:password@localhost/dbname\")\nmanager = PostgresManager.from_engine(\n    engine, \n    schema=\"public\" # (1) \n)\n</code></pre> <ol> <li>The schema where your tenant-aware tables are located.  All sessions and RLS checks will be scoped to this schema.</li> </ol> <p>Note</p> <p>If you're working with multiple schemas, create a separate DBManager for each one.    </p>"},{"location":"#6-use-the-dbmanager","title":"6. Use the DBManager","text":"<p><code>sqlalchemy-tenants</code> provides a built-in session manager to simplify the creation of  tenant-scoped sessions.</p> <p>You can instantiate it from your SQLAlchemy engine, and then use it to create sessions  automatically scoped to a specific tenant:</p> SyncAsync <pre><code>with manager.new_tenant_session(\"tenant_1\") as session:\n    # \u2705 Only returns tenant_1\u2019s rows, even if you forget to filter by tenant\n    session.execute(select(MyTable))\n</code></pre> <pre><code>async def main() -&gt; None:\n    async with manager.new_tenant_session(\"tenant_1\") as session:\n        # \u2705 Only returns tenant_1\u2019s rows, even if you forget to filter by tenant\n        await session.execute(select(MyTable))\n</code></pre>"},{"location":"#want-more","title":"\ud83d\udd0d Want more?","text":"<p>Check out the Examples page for more practical use cases.</p>"},{"location":"best-practices/","title":"Best practices","text":"<ul> <li> <p>Don't omit where tenant= in queries for performance reasons.</p> </li> <li> <p>Create tenants in advance</p> </li> </ul>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#core-module","title":"Core Module","text":"<p>The core functionality of sqlalchemy-tenants.</p>"},{"location":"reference/#sqlalchemy_tenants.core.get_table_policy","title":"get_table_policy","text":"<pre><code>get_table_policy(\n    *, table_name: str, column_type: Type[TenantIdentifier]\n) -&gt; str\n</code></pre> <p>Returns the SQL policy for a given table name.</p> Source code in <code>src/sqlalchemy_tenants/core.py</code> <pre><code>def get_table_policy(*, table_name: str, column_type: Type[TenantIdentifier]) -&gt; str:\n    \"\"\"\n    Returns the SQL policy for a given table name.\n    \"\"\"\n    if column_type is str:\n        sql_type = \"varchar\"\n    elif column_type is int:\n        sql_type = \"integer\"\n    elif column_type is UUID:\n        sql_type = \"uuid\"\n    else:\n        raise TypeError(f\"Unknown column type {column_type}\")\n    policy = _POLICY_TEMPLATE.format(\n        table_name=table_name,\n        get_tenant_fn=GET_TENANT_FUNCTION_NAME,\n        policy_name=_POLICY_NAME,\n        sql_type=sql_type,\n    )\n    return normalize_whitespace(policy)\n</code></pre>"},{"location":"reference/#sqlalchemy_tenants.core.get_tenant_role_name","title":"get_tenant_role_name","text":"<pre><code>get_tenant_role_name(tenant: TenantIdentifier) -&gt; str\n</code></pre> <p>Get the Postgres role name for the given tenant.</p> <p>Parameters:</p> Name Type Description Default <code>tenant</code> <code>TenantIdentifier</code> <p>the tenant slug.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The Postgres role name for the tenant.</p> Source code in <code>src/sqlalchemy_tenants/core.py</code> <pre><code>def get_tenant_role_name(tenant: TenantIdentifier) -&gt; str:\n    \"\"\"\n    Get the Postgres role name for the given tenant.\n\n    Args:\n        tenant: the tenant slug.\n\n    Returns:\n        The Postgres role name for the tenant.\n    \"\"\"\n    return f\"{TENANT_ROLE_PREFIX}{str(tenant)}\"\n</code></pre>"},{"location":"reference/#sqlalchemy_tenants.core.with_rls","title":"with_rls","text":"<pre><code>with_rls(cls: Type[T]) -&gt; Type[T]\n</code></pre> <p>Decorator to apply RLS (Row Level Security) to a SQLAlchemy model. Validates that the model includes a 'tenant' column.</p> Source code in <code>src/sqlalchemy_tenants/core.py</code> <pre><code>def with_rls(cls: Type[T]) -&gt; Type[T]:\n    \"\"\"\n    Decorator to apply RLS (Row Level Security) to a SQLAlchemy model.\n    Validates that the model includes a 'tenant' column.\n    \"\"\"\n    mapper = inspect(cls, raiseerr=False)\n    if mapper is None:\n        raise TypeError(\n            f\"@with_rls must be applied to a SQLAlchemy ORM model class, got: {cls}\"\n        )\n\n    if \"tenant\" not in mapper.columns:\n        raise TypeError(\n            f\"Model '{cls.__name__}' is marked for RLS but is missing a required \"\n            f\"'tenant' column.\"\n            \"\\nHint: you can use 'sqlalchemy_tenant TenantMixin' class to add it \"\n            \"easily.\"\n        )\n\n    tenant_column = mapper.columns[\"tenant\"]\n    if tenant_column.type.python_type not in TENANT_SUPPORTED_TYPES:\n        raise TypeError(\n            f\"Model '{cls.__name__}' is marked for RLS but 'tenant' \"\n            f\"has type '{tenant_column.type.python_type}', expected one \"\n            f\"of the following: {', '.join(map(str, TENANT_SUPPORTED_TYPES))}.\"\n        )\n\n    setattr(cls.__table__, _ATTRIBUTE_RLS_ENABLED, True)\n    setattr(\n        cls.__table__, _ATTRIBUTE_TENANT_COLUMN_TYPE, tenant_column.type.python_type\n    )\n    return cls\n</code></pre>"},{"location":"reference/#managers","title":"Managers","text":""},{"location":"reference/#sqlalchemy_tenants.managers.DBManager","title":"sqlalchemy_tenants.managers.DBManager","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"reference/#sqlalchemy_tenants.managers.DBManager.create_tenant","title":"create_tenant  <code>abstractmethod</code>","text":"<pre><code>create_tenant(tenant: TenantIdentifier) -&gt; None\n</code></pre> <p>Create a new tenant with the specified identifier.</p> <p>Parameters:</p> Name Type Description Default <code>tenant</code> <code>TenantIdentifier</code> <p>The identifier (slug or ID) of the tenant to create.</p> required Source code in <code>src/sqlalchemy_tenants/managers.py</code> <pre><code>@abstractmethod\ndef create_tenant(self, tenant: TenantIdentifier) -&gt; None:\n    \"\"\"\n    Create a new tenant with the specified identifier.\n\n    Args:\n        tenant: The identifier (slug or ID) of the tenant to create.\n    \"\"\"\n</code></pre>"},{"location":"reference/#sqlalchemy_tenants.managers.DBManager.delete_tenant","title":"delete_tenant  <code>abstractmethod</code>","text":"<pre><code>delete_tenant(tenant: TenantIdentifier) -&gt; None\n</code></pre> <p>Delete a tenant and all its associated roles and privileges, reassigning owned objects to the current user.</p> <p>No data will be deleted, only the role and privileges.</p> <p>Parameters:</p> Name Type Description Default <code>tenant</code> <code>TenantIdentifier</code> <p>The identifier of the tenant to delete.</p> required Source code in <code>src/sqlalchemy_tenants/managers.py</code> <pre><code>@abstractmethod\ndef delete_tenant(self, tenant: TenantIdentifier) -&gt; None:\n    \"\"\"\n    Delete a tenant and all its associated roles and privileges,\n    reassigning owned objects to the current user.\n\n    No data will be deleted, only the role and privileges.\n\n    Args:\n        tenant: The identifier of the tenant to delete.\n    \"\"\"\n</code></pre>"},{"location":"reference/#sqlalchemy_tenants.managers.DBManager.list_tenants","title":"list_tenants  <code>abstractmethod</code>","text":"<pre><code>list_tenants() -&gt; Set[TenantIdentifier]\n</code></pre> <p>Get all the available tenants.</p> <p>Returns:</p> Type Description <code>Set[TenantIdentifier]</code> <p>A set with all the available tenants.</p> Source code in <code>src/sqlalchemy_tenants/managers.py</code> <pre><code>@abstractmethod\ndef list_tenants(self) -&gt; Set[TenantIdentifier]:\n    \"\"\"\n    Get all the available tenants.\n\n    Returns:\n        A set with all the available tenants.\n    \"\"\"\n</code></pre>"},{"location":"reference/#sqlalchemy_tenants.managers.DBManager.new_tenant_session","title":"new_tenant_session  <code>abstractmethod</code>","text":"<pre><code>new_tenant_session(\n    tenant: TenantIdentifier, create_if_missing: bool = True\n) -&gt; ContextManager[TenantSession]\n</code></pre> <p>Create a new SQLAlchemy session scoped to a specific tenant.</p> <p>The session uses the tenant's PostgreSQL role and is subject to Row-Level Security (RLS) policies. All queries and writes are automatically restricted to data belonging to the specified tenant.</p> <p>Parameters:</p> Name Type Description Default <code>tenant</code> <code>TenantIdentifier</code> <p>The identifier of the tenant.</p> required <code>create_if_missing</code> <code>bool</code> <p>Whether to create the tenant role if it doesn't exist.</p> <code>True</code> <p>Yields:</p> Type Description <code>ContextManager[TenantSession]</code> <p>A SQLAlchemy session restricted to the tenant's data via RLS.</p> <p>Raises:</p> Type Description <code>TenantNotFound</code> <p>If the tenant role doesn't exist and <code>create_if_missing</code> is False.</p> Source code in <code>src/sqlalchemy_tenants/managers.py</code> <pre><code>@abstractmethod\ndef new_tenant_session(\n    self,\n    tenant: TenantIdentifier,\n    create_if_missing: bool = True,\n) -&gt; ContextManager[TenantSession]:\n    \"\"\"\n    Create a new SQLAlchemy session scoped to a specific tenant.\n\n    The session uses the tenant's PostgreSQL role and is subject to Row-Level\n    Security (RLS) policies. All queries and writes are automatically restricted\n    to data belonging to the specified tenant.\n\n    Args:\n        tenant: The identifier of the tenant.\n        create_if_missing: Whether to create the tenant role if it doesn't exist.\n\n    Yields:\n        A SQLAlchemy session restricted to the tenant's data via RLS.\n\n    Raises:\n        TenantNotFound: If the tenant role doesn't exist and `create_if_missing`\n            is False.\n    \"\"\"\n</code></pre>"},{"location":"reference/#sqlalchemy_tenants.managers.DBManager.new_session","title":"new_session  <code>abstractmethod</code>","text":"<pre><code>new_session() -&gt; ContextManager[Session]\n</code></pre> <p>Create a new admin session with unrestricted access to all tenant data.</p> <p>This session is not bound to any tenant role and is not subject to RLS policies.</p> <p>Yields:</p> Type Description <code>ContextManager[Session]</code> <p>An asynchronous SQLAlchemy session with full database access.</p> Source code in <code>src/sqlalchemy_tenants/managers.py</code> <pre><code>@abstractmethod\ndef new_session(self) -&gt; ContextManager[Session]:\n    \"\"\"\n    Create a new admin session with unrestricted access to all tenant data.\n\n    This session is not bound to any tenant role and is not subject to\n    RLS policies.\n\n    Yields:\n        An asynchronous SQLAlchemy session with full database access.\n    \"\"\"\n</code></pre>"},{"location":"reference/#sqlalchemy_tenants.managers.PostgresManager","title":"sqlalchemy_tenants.managers.PostgresManager","text":"<pre><code>PostgresManager(\n    schema_name: str,\n    engine: Engine,\n    session_maker: sessionmaker[Session],\n)\n</code></pre> <p>               Bases: <code>DBManager</code></p> Source code in <code>src/sqlalchemy_tenants/managers.py</code> <pre><code>def __init__(\n    self,\n    schema_name: str,\n    engine: Engine,\n    session_maker: sessionmaker[Session],\n) -&gt; None:\n    self.engine = engine\n    self.schema = schema_name\n    self.session_maker = session_maker\n</code></pre>"},{"location":"reference/#managers-async","title":"Managers [async]","text":""},{"location":"reference/#sqlalchemy_tenants.aio.managers.DBManager","title":"sqlalchemy_tenants.aio.managers.DBManager","text":"<p>               Bases: <code>Protocol</code></p>"},{"location":"reference/#sqlalchemy_tenants.aio.managers.DBManager.create_tenant","title":"create_tenant  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>create_tenant(tenant: TenantIdentifier) -&gt; None\n</code></pre> <p>Create a new tenant with the specified identifier.</p> <p>Parameters:</p> Name Type Description Default <code>tenant</code> <code>TenantIdentifier</code> <p>The identifier of the tenant to create.</p> required Source code in <code>src/sqlalchemy_tenants/aio/managers.py</code> <pre><code>@abstractmethod\nasync def create_tenant(self, tenant: TenantIdentifier) -&gt; None:\n    \"\"\"\n    Create a new tenant with the specified identifier.\n\n    Args:\n        tenant: The identifier of the tenant to create.\n    \"\"\"\n</code></pre>"},{"location":"reference/#sqlalchemy_tenants.aio.managers.DBManager.delete_tenant","title":"delete_tenant  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete_tenant(tenant: TenantIdentifier) -&gt; None\n</code></pre> <p>Delete a tenant and all its associated roles and privileges, reassigning owned objects to the current user.</p> <p>No data will be deleted, only the role and privileges.</p> <p>Parameters:</p> Name Type Description Default <code>tenant</code> <code>TenantIdentifier</code> <p>The identifier of the tenant to delete.</p> required Source code in <code>src/sqlalchemy_tenants/aio/managers.py</code> <pre><code>@abstractmethod\nasync def delete_tenant(self, tenant: TenantIdentifier) -&gt; None:\n    \"\"\"\n    Delete a tenant and all its associated roles and privileges,\n    reassigning owned objects to the current user.\n\n    No data will be deleted, only the role and privileges.\n\n    Args:\n        tenant: The identifier of the tenant to delete.\n    \"\"\"\n</code></pre>"},{"location":"reference/#sqlalchemy_tenants.aio.managers.DBManager.list_tenants","title":"list_tenants  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>list_tenants() -&gt; Set[TenantIdentifier]\n</code></pre> <p>Get all the available tenants.</p> <p>Returns:</p> Type Description <code>Set[TenantIdentifier]</code> <p>A set with all the available tenants.</p> Source code in <code>src/sqlalchemy_tenants/aio/managers.py</code> <pre><code>@abstractmethod\nasync def list_tenants(self) -&gt; Set[TenantIdentifier]:\n    \"\"\"\n    Get all the available tenants.\n\n    Returns:\n        A set with all the available tenants.\n    \"\"\"\n</code></pre>"},{"location":"reference/#sqlalchemy_tenants.aio.managers.DBManager.new_tenant_session","title":"new_tenant_session  <code>abstractmethod</code>","text":"<pre><code>new_tenant_session(\n    tenant: TenantIdentifier, create_if_missing: bool = True\n) -&gt; AsyncContextManager[AsyncTenantSession]\n</code></pre> <p>Create a new SQLAlchemy session scoped to a specific tenant.</p> <p>The session uses the tenant's PostgreSQL role and is subject to Row-Level Security (RLS) policies. All queries and writes are automatically restricted to data belonging to the specified tenant.</p> <p>Parameters:</p> Name Type Description Default <code>tenant</code> <code>TenantIdentifier</code> <p>The tenant identifier, which must match a valid PostgreSQL role used for RLS enforcement.</p> required <code>create_if_missing</code> <code>bool</code> <p>Whether to create the tenant role if it doesn't exist.</p> <code>True</code> <p>Yields:</p> Type Description <code>AsyncContextManager[AsyncTenantSession]</code> <p>A SQLAlchemy session restricted to the tenant's data via RLS.</p> <p>Raises:</p> Type Description <code>TenantNotFound</code> <p>If the tenant role doesn't exist and <code>create_if_missing</code> is False.</p> Source code in <code>src/sqlalchemy_tenants/aio/managers.py</code> <pre><code>@abstractmethod\ndef new_tenant_session(\n    self,\n    tenant: TenantIdentifier,\n    create_if_missing: bool = True,\n) -&gt; AsyncContextManager[AsyncTenantSession]:\n    \"\"\"\n    Create a new SQLAlchemy session scoped to a specific tenant.\n\n    The session uses the tenant's PostgreSQL role and is subject to Row-Level\n    Security (RLS) policies. All queries and writes are automatically restricted\n    to data belonging to the specified tenant.\n\n    Args:\n        tenant: The tenant identifier, which must match a valid PostgreSQL role\n            used for RLS enforcement.\n        create_if_missing: Whether to create the tenant role if it doesn't exist.\n\n    Yields:\n        A SQLAlchemy session restricted to the tenant's data via RLS.\n\n    Raises:\n        TenantNotFound: If the tenant role doesn't exist and `create_if_missing`\n            is False.\n    \"\"\"\n</code></pre>"},{"location":"reference/#sqlalchemy_tenants.aio.managers.DBManager.new_session","title":"new_session  <code>abstractmethod</code>","text":"<pre><code>new_session() -&gt; AsyncContextManager[AsyncSession]\n</code></pre> <p>Create a new admin session with unrestricted access to all tenant data.</p> <p>This session is not bound to any tenant role and is not subject to RLS policies.</p> <p>Yields:</p> Type Description <code>AsyncContextManager[AsyncSession]</code> <p>An asynchronous SQLAlchemy session with full database access.</p> Source code in <code>src/sqlalchemy_tenants/aio/managers.py</code> <pre><code>@abstractmethod\ndef new_session(self) -&gt; AsyncContextManager[AsyncSession]:\n    \"\"\"\n    Create a new admin session with unrestricted access to all tenant data.\n\n    This session is not bound to any tenant role and is not subject to\n    RLS policies.\n\n    Yields:\n        An asynchronous SQLAlchemy session with full database access.\n    \"\"\"\n</code></pre>"},{"location":"reference/#sqlalchemy_tenants.aio.managers.PostgresManager","title":"sqlalchemy_tenants.aio.managers.PostgresManager","text":"<pre><code>PostgresManager(\n    schema_name: str,\n    engine: AsyncEngine,\n    session_maker: async_sessionmaker[AsyncSession],\n)\n</code></pre> <p>               Bases: <code>DBManager</code></p> Source code in <code>src/sqlalchemy_tenants/aio/managers.py</code> <pre><code>def __init__(\n    self,\n    schema_name: str,\n    engine: AsyncEngine,\n    session_maker: async_sessionmaker[AsyncSession],\n) -&gt; None:\n    self.engine = engine\n    self.schema = schema_name\n    self.session_maker = session_maker\n</code></pre>"},{"location":"reference/#exceptions","title":"Exceptions","text":"<p>Exception classes used throughout the library.</p>"},{"location":"reference/#sqlalchemy_tenants.exceptions.SqlalchemyTenantErr","title":"SqlalchemyTenantErr","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all exceptions raised by the tenants package.</p>"},{"location":"reference/#sqlalchemy_tenants.exceptions.TenantAlreadyExists","title":"TenantAlreadyExists","text":"<pre><code>TenantAlreadyExists(tenant: TenantIdentifier)\n</code></pre> <p>               Bases: <code>SqlalchemyTenantErr</code></p> <p>Raised when trying to create a tenant that already exists.</p> Source code in <code>src/sqlalchemy_tenants/exceptions.py</code> <pre><code>def __init__(self, tenant: TenantIdentifier) -&gt; None:\n    super().__init__(f\"Tenant '{tenant}' already exists.\")\n</code></pre>"},{"location":"reference/#sqlalchemy_tenants.exceptions.TenantNotFound","title":"TenantNotFound","text":"<pre><code>TenantNotFound(tenant: TenantIdentifier)\n</code></pre> <p>               Bases: <code>SqlalchemyTenantErr</code></p> <p>Raised when a tenant is not found.</p> Source code in <code>src/sqlalchemy_tenants/exceptions.py</code> <pre><code>def __init__(self, tenant: TenantIdentifier) -&gt; None:\n    super().__init__(f\"Tenant '{tenant}' not found.\")\n</code></pre>"},{"location":"tenants/","title":"Managing tenants","text":"<p><code>sqlalchemy-tenants</code> focus is on enforcing data isolation among tenants. As such, it assumes you already have a system for managing and controlling your tenants and respective settings.</p> <p>In most cases, you\u2019ll already have a table or service that tracks tenant metadata and configuration. <code>sqlalchemy-tenants</code> expects you to use the same tenant identifier (e.g., a slug or ID) in any table that should be tenant-aware, via a column named <code>tenant</code>. This identifier is also used to create the corresponding database roles and row-level security (RLS) policies for each tenant.</p>"},{"location":"tenants/#creating-tenants","title":"Creating tenants","text":"<p>You can create tenants manually (recommended) or on the fly during session creation.</p>"},{"location":"tenants/#option-1-manually-recommended","title":"Option 1 \u2013 Manually (Recommended)","text":"<p>Use <code>DBManager.create_tenant()</code> to pre-configure a tenant's database role and RLS policies.</p> <p>This ensures the tenant is fully set up before the first session, avoiding delays  during normal usage. It\u2019s best to call <code>create_tenant()</code> from your tenant creation logic.</p> <p>Example:</p> <pre><code>manager = PostgresManager.from_engine(engine)\n\ndef create_tenant(tenant: str | int | UUID) -&gt; None:\n    # 1. Store tenant metadata\n    # 2. Setup database-level access\n    manager.create_tenant(tenant)\n</code></pre> <p>Tip</p> <p>Manual creation is recommended for production environments where predictable startup performance is important.</p>"},{"location":"tenants/#option-2-on-the-fly","title":"Option 2 \u2013 On the Fly","text":"<p>You can also defer tenant creation to first usage.  By default, DBManager.new_tenant_session()  will automatically create the tenant if it doesn\u2019t exist (unless <code>create_if_missing=False</code>).</p> <p>This simplifies onboarding but may introduce a slight delay the first  time a session is opened for a tenant.</p> <p>Warning</p> <p>Expect a short delay the first time a session is created if the tenant hasn\u2019t been set up manually.</p>"},{"location":"tenants/#deleting-tenants","title":"Deleting tenants","text":"<p>Use <code>DBManager.delete_tenant()</code> to remove a tenant\u2019s database role and RLS policies. This can be useful when a tenant is decommissioned or no longer needs isolated access.</p> <p>Example:</p> <pre><code>manager.delete_tenant(\"my_tenant\")\n</code></pre> <p>Warning</p> <p>Deleting a tenant does not delete its data from your tables. You'll need to explicitly remove tenant data from your application-level  storage (e.g., via <code>DELETE FROM table WHERE tenant = 'my_tenant'</code>) if that\u2019s required.</p>"},{"location":"examples/","title":"Examples","text":"<ul> <li>FastAPI Integration:    How to use sqlalchemy-tenants with FastAPI to automatically scope requests to the correct tenant.</li> </ul>"},{"location":"examples/fastapi-integration/","title":"FastAPI Integration","text":""},{"location":"examples/fastapi-integration/#overview","title":"Overview","text":"<p>This example shows how to use sqlalchemy-tenants to build a multi-tenant FastAPI service where each request is automatically scoped to the correct tenant.</p> <p>This enforces tenant isolation at the database level, so even if you forget to filter by tenant in your queries, there's no risk of data leaking between tenants.</p> <p>We'll use PostgreSQL for this example. We assume you already have ORM models defined using SQLAlchemy. In this case, we'll use a simple <code>TodoItem</code> model.</p> <p>Info</p> <p>You can find the full source code for this example in  examples/fastapi_tenants.</p>"},{"location":"examples/fastapi-integration/#steps","title":"Steps","text":""},{"location":"examples/fastapi-integration/#1-enable-multi-tenancy-on-your-models","title":"1. Enable multi-tenancy on your models","text":"<p>Let's enable multi-tenancy by adding a <code>tenant</code> column to our model and applying the <code>@with_rls</code> decorator.</p> orm.py<pre><code>from sqlalchemy_tenants import with_rls\n\n\n@with_rls\nclass TodoItem(Base):\n    __tablename__ = \"todo_item\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column()\n    tenant: Mapped[str] = mapped_column()  \n</code></pre>"},{"location":"examples/fastapi-integration/#2-update-alembic-envpy","title":"2. Update Alembic <code>env.py</code>","text":"<p>Include sqlalchemy-tenants in your Alembic <code>env.py</code> to automatically generate RLS policies and functions in your migrations.</p> <p>You can just add the function <code>get_process_revision_directives</code> to your <code>context.configure</code> call in your alembic <code>env.py</code>:</p> env.py<pre><code>from alembic import context\nfrom app.db.orm import Base\nfrom sqlalchemy_tenants import get_process_revision_directives\n\ntarget_metadata = Base.metadata\n\ncontext.configure(\n    # ...\n    process_revision_directives=get_process_revision_directives(target_metadata),\n    # ...\n)\n</code></pre>"},{"location":"examples/fastapi-integration/#3-generate-the-alembic-migration","title":"3. Generate the alembic migration","text":"<p>Generate alembic migrations to add the <code>tenant</code> column and enable row-level security ( RLS) on the table.</p> <pre><code>alembic revision --autogenerate -m \"Add tenant column and enable RLS\"\n</code></pre>"},{"location":"examples/fastapi-integration/#4-instantiate-a-dbmanager","title":"4. Instantiate a DBManager","text":"<p>We need a <code>DBManager</code> to manage tenant sessions and enforce RLS policies. To create it, we need first to create a sqlalchemy engine. We'll using the async version of the manager with asyncpg. We'll read the database connection settings from environment variables using Pydantic.</p> engine.py<pre><code>class PostgresSettings(BaseSettings):\n    SERVER: str\n    USER: str\n    PASSWORD: str\n    DB: str\n    STATEMENT_TIMEOUT_SECONDS: int = 120\n\n    model_config = {\n        \"env_prefix\": \"POSTGRES_\",\n    }\n\n    @cached_property\n    def escaped_password(self) -&gt; str:\n        \"\"\"\n        Escape the password for use in a Postgres URI.\n        \"\"\"\n        return urllib.parse.quote(self.PASSWORD)\n\n    def get_dsn(self) -&gt; PostgresDsn:\n        \"\"\"\n        Return the DSN for a given Postgres server.\n        \"\"\"\n        return PostgresDsn.build(\n            scheme=\"postgresql+asyncpg\",\n            username=self.USER,\n            password=self.escaped_password,\n            host=self.SERVER,\n            path=self.DB,\n        )\n\n\nsettings = PostgresSettings()  # type: ignore[call-arg]\nengine = create_async_engine(str(settings.get_dsn()))\nmanager = PostgresManager.from_engine(engine, schema_name=\"public\")\n</code></pre>"},{"location":"examples/fastapi-integration/#5-create-a-fastapi-dependency-to-extract-the-tenant","title":"5. Create a FastAPI dependency to extract the tenant","text":"<p>We\u2019ll define a FastAPI dependency that extracts the tenant ID from the incoming request.</p> <p>In this example, we assume requests are authenticated using a JWT access token, and that the tenant identifier is stored in the <code>tenant</code> claim.</p> <p>Warning</p> <p>This is a simplified example and skips actual JWT verification.</p> dependencies.py<pre><code>import logging\nfrom typing import Annotated\n\nimport jose\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPAuthorizationCredentials, HTTPBearer\nfrom jose import jwt\nfrom starlette.status import HTTP_401_UNAUTHORIZED\n\nlogger = logging.getLogger(__name__)\n\n\ndef _extract_tenant(\n    credential: Annotated[\n        HTTPAuthorizationCredentials | None,\n        Depends(HTTPBearer(auto_error=False)),\n    ],\n) -&gt; str:\n    if credential is None:\n        raise HTTPException(status_code=HTTP_401_UNAUTHORIZED)\n    try:\n        access_token = jwt.decode(\n            credential.credentials,\n            key=\"\",\n            audience=\"example\",\n            subject=\"example\",\n            algorithms=[\"HS256\"],\n            options={\n                \"verify_signature\": False,\n                \"verify_aud\": False,\n                \"verify_sub\": False,\n            },\n        )\n        return access_token[\"tenant\"]\n    except jose.exceptions.JWTError as e:\n        logger.debug(\"token decode error\", exc_info=e)\n        raise HTTPException(status_code=HTTP_401_UNAUTHORIZED)\n    except KeyError:\n        raise HTTPException(status_code=HTTP_401_UNAUTHORIZED)\n\n\nTenant_T = Annotated[str, Depends(_extract_tenant)]\n</code></pre> <p>We can now use <code>Tenant_T</code> as a dependency to extract the tenant from each request.</p>"},{"location":"examples/fastapi-integration/#6-create-a-dependency-for-a-tenant-scoped-db-session","title":"6. Create a dependency for a tenant-scoped DB session","text":"<p>Now we\u2019ll define a FastAPI dependency that returns a SQLAlchemy AsyncSession scoped to the current tenant.</p> <p>This uses the <code>PostgresManager</code> instance created earlier to generate a session that enforces the correct RLS policies for the tenant extracted in step 4.</p> dependencies.py<pre><code>async def _new_db_session(\n    tenant: Tenant_T,\n) -&gt; AsyncGenerator[AsyncTenantSession, None]:\n    async with manager.new_tenant_session(tenant=tenant) as sess:\n        yield sess\n\n\nDatabase_T = Annotated[AsyncSession, Depends(_new_db_session)]\n</code></pre>"},{"location":"examples/fastapi-integration/#7-use-the-tenant-scoped-session-in-your-fastapi-routes","title":"7. Use the tenant-scoped session in your FastAPI routes","text":"<p>You can now use the <code>Database_T</code> dependency in your routes to automatically scope all database operations to the current tenant, enforced by Postgres row-level security.</p> main.py<pre><code>from fastapi import APIRouter\nfrom sqlalchemy import select\nfrom app.dependencies import Database_T\nfrom app.orm import TodoItem\n\nrouter = APIRouter()\n\n\n@router.get(\"/todos\")\nasync def list_todos(db: Database_T) -&gt; list[TodoItem]:\n    query = select(TodoItem).where(TodoItem.tenant == db.tenant) # (1)\n    result = await db.execute(query)\n    return result.scalars().all()\n</code></pre> <ol> <li>While RLS enforces tenant isolation at the database level, it\u2019s still recommended to explicitly filter by tenant in your queries. This allows Postgres to optimize the query plan and significantly improves performance \u2014 especially on large tables.</li> </ol>"}]}